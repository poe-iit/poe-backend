from .poe_data import *

import socket
from _thread import *
from collections import deque

# socket.SOCK_STREAM = TCP
# socket.SOCK_DGRAM = UDP (Switch To UDP if performance bottleneck appears via network limitations)
# Leave Connection Open For Arduino Communication (do not close for performance reasons)

class Sys:
    def __init__(self, ip, port, max_connections, poe_db):
        global poe_main
        poe_main = self

        # Not sure if 100% db needs a lock, just assumed so
        self.db_lock        = allocate_lock()
        self.db             = poe_db

        self.connections    = []
        self.server         = None
        self.verbose        = False

        self.start_server(ip, port, max_connections)

    def auto_resolve_ip(self): # Unused for now
        local_ip = "127.0.0.1" # Listen Local Host (Within PC)
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0] # Listen default lan IP
        except:
            local_ip = "0.0.0.0" # Listen All
        print("listening on: " + local_ip)
        return local_ip
        
    def set_verbose(self, status : bool):
        self.verbose = status

    def post_update_db(self, data):
        unpack_data = data.to_tupple()
        self.db_lock.acquire()
        self.db.upload(unpack_data)
        self.db_lock.release()

    def list_connections(self, opt):
        for connection in self.connections:
            print(connection)

    def start_client(self, client, address):
        # How to secure the system:
        # Use digital signatures with timestamps
        # > Verifies authenticity of source while preventing replay attacks
        # Alternatively, instead of timestamps, use random num generated by poe_sys
        while True:
            try:
                # 4 (larger maybe better for efficeny, not verified, just hearsay)
                data = client.recv(1024)

                if not data:
                    continue
                
                if self.verbose:
                    print("[LOG]: poe_sys received {}".format(data))

                if len(data) % 4 != 0:
                    print("[ERROR]: Incompatible byte array received data from " + str(address[0]) + ":" + str(address[1]))
                    continue

                for i in range(0, len(data), 4):
                    opt     = int.from_bytes([data[i]],   "big")
                    id      = int.from_bytes([data[i+1]], "big")
                    type    = int.from_bytes([data[i+2]], "big")
                    reading = int.from_bytes([data[i+3]], "big")
                    
                    self.post_update_db(sensor(address[0], address[1], str(id), type, reading))

                # Add keepalive, or find built in function to check conn status?
            except Exception as e:
                print(e)
                print("[ERROR]: Error reading received data from " + str(address[0]) + ":" + str(address[1]))
        client.close()
    
    def server_loop(self):
        while True:
            # Sockets
            client, address = self.server.accept()
            print("{}Connection Estabilished - {} : {}{}".format("\033[92m", address[0], address[1], "\033[0m"))
            thd = start_new_thread(self.start_client, (client, address))
            self.connections.append((thd, client, address))


    def start_server(self, ip, port, max_connections):
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.bind((ip, port))
        self.server.listen(max_connections)

        start_new_thread(self.server_loop, ())


